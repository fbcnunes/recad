<?php

declare(strict_types=1);

function readEnvFile(string $path): array
{
    if (!is_file($path)) {
        throw new RuntimeException(".env file not found: {$path}");
    }

    $vars = [];
    $lines = file($path, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
    if ($lines === false) {
        throw new RuntimeException("Unable to read .env file: {$path}");
    }

    foreach ($lines as $line) {
        $line = trim($line);
        if ($line === '' || str_starts_with($line, '#')) {
            continue;
        }
        $pos = strpos($line, '=');
        if ($pos === false) {
            continue;
        }

        $key = trim(substr($line, 0, $pos));
        $value = trim(substr($line, $pos + 1));

        if ($value !== '' && (
            (str_starts_with($value, '"') && str_ends_with($value, '"')) ||
            (str_starts_with($value, "'") && str_ends_with($value, "'"))
        )) {
            $value = substr($value, 1, -1);
        }

        $vars[$key] = $value;
    }

    return $vars;
}

function qi(string $identifier): string
{
    return '"' . str_replace('"', '""', $identifier) . '"';
}

function mi(string $identifier): string
{
    return '`' . str_replace('`', '``', $identifier) . '`';
}

function qs(string $value): string
{
    return "'" . str_replace("'", "''", $value) . "'";
}

function normalizeRule(string $rule): string
{
    $rule = strtoupper(trim($rule));
    return match ($rule) {
        'CASCADE', 'SET NULL', 'SET DEFAULT', 'RESTRICT', 'NO ACTION' => $rule,
        default => 'NO ACTION',
    };
}

function mapType(array $col): array
{
    $dataType = strtolower((string) ($col['data_type'] ?? ''));
    $columnType = strtolower((string) ($col['column_type'] ?? ''));
    $length = $col['character_maximum_length'] ?? null;
    $precision = $col['numeric_precision'] ?? null;
    $scale = $col['numeric_scale'] ?? null;
    $isIdentity = str_contains(strtolower((string) ($col['extra'] ?? '')), 'auto_increment');

    $pgType = 'TEXT';
    $kind = 'text';

    switch ($dataType) {
        case 'bigint':
            $pgType = 'BIGINT';
            $kind = 'integer';
            break;
        case 'int':
        case 'integer':
        case 'mediumint':
            $pgType = 'INTEGER';
            $kind = 'integer';
            break;
        case 'smallint':
        case 'tinyint':
            $pgType = 'SMALLINT';
            $kind = 'integer';
            break;
        case 'decimal':
        case 'numeric':
            if ($precision !== null && $scale !== null) {
                $pgType = 'NUMERIC(' . (int) $precision . ',' . (int) $scale . ')';
            } elseif ($precision !== null) {
                $pgType = 'NUMERIC(' . (int) $precision . ')';
            } else {
                $pgType = 'NUMERIC';
            }
            $kind = 'numeric';
            break;
        case 'float':
            $pgType = 'REAL';
            $kind = 'numeric';
            break;
        case 'double':
            $pgType = 'DOUBLE PRECISION';
            $kind = 'numeric';
            break;
        case 'varchar':
            $pgType = $length !== null ? 'VARCHAR(' . (int) $length . ')' : 'VARCHAR';
            $kind = 'text';
            break;
        case 'char':
            $pgType = $length !== null ? 'CHAR(' . (int) $length . ')' : 'CHAR';
            $kind = 'text';
            break;
        case 'text':
        case 'tinytext':
        case 'mediumtext':
        case 'longtext':
            $pgType = 'TEXT';
            $kind = 'text';
            break;
        case 'json':
            $pgType = 'JSONB';
            $kind = 'json';
            break;
        case 'date':
            $pgType = 'DATE';
            $kind = 'date';
            break;
        case 'datetime':
        case 'timestamp':
            $pgType = 'TIMESTAMP';
            $kind = 'timestamp';
            break;
        case 'time':
            $pgType = 'TIME';
            $kind = 'time';
            break;
        case 'blob':
        case 'tinyblob':
        case 'mediumblob':
        case 'longblob':
        case 'binary':
        case 'varbinary':
            $pgType = 'BYTEA';
            $kind = 'bytea';
            break;
        default:
            $pgType = 'TEXT';
            $kind = 'text';
            break;
    }

    if ($isIdentity && in_array($pgType, ['SMALLINT', 'INTEGER', 'BIGINT'], true)) {
        $pgType .= ' GENERATED BY DEFAULT AS IDENTITY';
    }

    return [$pgType, $kind, $isIdentity, $columnType];
}

function mapDefault(array $colMeta, $defaultValue): string
{
    if ($defaultValue === null || $colMeta['is_identity']) {
        return '';
    }

    $def = trim((string) $defaultValue);
    if ($def === '') {
        return '';
    }

    $lower = strtolower($def);
    if ($lower === 'current_timestamp' || $lower === 'current_timestamp()') {
        return ' DEFAULT CURRENT_TIMESTAMP';
    }

    if (str_starts_with($lower, 'current_timestamp(')) {
        return ' DEFAULT CURRENT_TIMESTAMP';
    }

    if (preg_match("/^b'([01])'$/", $def, $m) === 1) {
        return ' DEFAULT ' . $m[1];
    }

    if (in_array($colMeta['kind'], ['integer', 'numeric'], true) && preg_match('/^-?\\d+(?:\\.\\d+)?$/', $def) === 1) {
        return ' DEFAULT ' . $def;
    }

    return ' DEFAULT ' . qs($def);
}

function pgLiteral($value, array $colMeta): string
{
    if ($value === null) {
        return 'NULL';
    }

    switch ($colMeta['kind']) {
        case 'integer':
        case 'numeric':
            if ($value === '' || !is_numeric((string) $value)) {
                return 'NULL';
            }
            return (string) $value;
        case 'bytea':
            return qs('\\x' . bin2hex((string) $value)) . '::bytea';
        case 'json':
        case 'text':
        case 'date':
        case 'time':
        case 'timestamp':
        default:
            return qs((string) $value);
    }
}

$env = readEnvFile(__DIR__ . '/../.env');

if (($env['DB_CONNECTION'] ?? '') !== 'mysql') {
    throw new RuntimeException('DB_CONNECTION is not mysql in .env');
}

$host = $env['DB_HOST'] ?? '127.0.0.1';
$port = (int) ($env['DB_PORT'] ?? 3306);
$dbName = $env['DB_DATABASE'] ?? '';
$user = $env['DB_USERNAME'] ?? '';
$pass = $env['DB_PASSWORD'] ?? '';

if ($dbName === '' || $user === '') {
    throw new RuntimeException('Missing DB_DATABASE or DB_USERNAME in .env');
}

$dsn = "mysql:host={$host};port={$port};dbname={$dbName};charset=utf8mb4";
$pdo = new PDO($dsn, $user, $pass, [
    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
    PDO::ATTR_CASE => PDO::CASE_LOWER,
    PDO::MYSQL_ATTR_USE_BUFFERED_QUERY => false,
]);

$outPath = __DIR__ . '/../dumps/recad_postgresql_dump.sql';
$out = fopen($outPath, 'wb');
if ($out === false) {
    throw new RuntimeException('Cannot open output file: ' . $outPath);
}

fwrite($out, "-- PostgreSQL-compatible dump generated from MySQL database '{$dbName}'\n");
fwrite($out, '-- Generated at ' . gmdate('Y-m-d H:i:s') . " UTC\n\n");
fwrite($out, "BEGIN;\n");
fwrite($out, "SET client_encoding = 'UTF8';\n");
fwrite($out, "SET standard_conforming_strings = on;\n\n");

$tablesStmt = $pdo->prepare(
    "SELECT table_name
     FROM information_schema.tables
     WHERE table_schema = :db AND table_type = 'BASE TABLE'
     ORDER BY table_name"
);
$tablesStmt->execute(['db' => $dbName]);
$tables = $tablesStmt->fetchAll(PDO::FETCH_COLUMN);

// Fail fast when expected app tables are missing, which usually indicates
// pending migrations and would produce an outdated dump.
$requiredTables = [
    'users',
    'servidores',
    'servidor_confirmacoes',
    'admin_users',
];
$missingRequiredTables = array_values(array_diff($requiredTables, $tables));
if ($missingRequiredTables !== []) {
    throw new RuntimeException(
        'Missing required tables in source database: ' . implode(', ', $missingRequiredTables) .
        '. Run migrations before generating the PostgreSQL dump.'
    );
}

$schemaInfo = [];
$identityColumns = [];

$colStmt = $pdo->prepare(
    "SELECT column_name, data_type, column_type, is_nullable, column_default,
            character_maximum_length, numeric_precision, numeric_scale, extra,
            ordinal_position
     FROM information_schema.columns
     WHERE table_schema = :db AND table_name = :table
     ORDER BY ordinal_position"
);

$pkStmt = $pdo->prepare(
    "SELECT kcu.column_name
     FROM information_schema.table_constraints tc
     JOIN information_schema.key_column_usage kcu
       ON tc.table_schema = kcu.table_schema
      AND tc.table_name = kcu.table_name
      AND tc.constraint_name = kcu.constraint_name
     WHERE tc.table_schema = :db
       AND tc.table_name = :table
       AND tc.constraint_type = 'PRIMARY KEY'
     ORDER BY kcu.ordinal_position"
);

$uniqueStmt = $pdo->prepare(
    "SELECT index_name, column_name, seq_in_index
     FROM information_schema.statistics
     WHERE table_schema = :db
       AND table_name = :table
       AND non_unique = 0
       AND index_name <> 'PRIMARY'
     ORDER BY index_name, seq_in_index"
);

$indexStmt = $pdo->prepare(
    "SELECT index_name, column_name, seq_in_index
     FROM information_schema.statistics
     WHERE table_schema = :db
       AND table_name = :table
       AND non_unique = 1
     ORDER BY index_name, seq_in_index"
);

$fkStmt = $pdo->prepare(
    "SELECT kcu.constraint_name,
            kcu.column_name,
            kcu.referenced_table_name,
            kcu.referenced_column_name,
            kcu.ordinal_position,
            rc.update_rule,
            rc.delete_rule
     FROM information_schema.key_column_usage kcu
     JOIN information_schema.referential_constraints rc
       ON rc.constraint_schema = kcu.table_schema
      AND rc.constraint_name = kcu.constraint_name
     WHERE kcu.table_schema = :db
       AND kcu.table_name = :table
       AND kcu.referenced_table_name IS NOT NULL
     ORDER BY kcu.constraint_name, kcu.ordinal_position"
);

foreach ($tables as $table) {
    $colStmt->execute(['db' => $dbName, 'table' => $table]);
    $cols = $colStmt->fetchAll();

    $columnDefs = [];
    $colMeta = [];

    foreach ($cols as $col) {
        [$pgType, $kind, $isIdentity] = mapType($col);
        $name = (string) $col['column_name'];

        $meta = [
            'kind' => $kind,
            'is_identity' => $isIdentity,
        ];
        $colMeta[$name] = $meta;

        if ($isIdentity) {
            $identityColumns[] = ['table' => $table, 'column' => $name];
        }

        $nullSql = strtoupper((string) $col['is_nullable']) === 'NO' ? ' NOT NULL' : '';
        $defaultSql = mapDefault($meta, $col['column_default']);
        $columnDefs[] = '    ' . qi($name) . ' ' . $pgType . $defaultSql . $nullSql;
    }

    fwrite($out, 'DROP TABLE IF EXISTS ' . qi($table) . " CASCADE;\n");
    fwrite($out, 'CREATE TABLE ' . qi($table) . " (\n");
    fwrite($out, implode(",\n", $columnDefs));
    fwrite($out, "\n);\n\n");

    $pkStmt->execute(['db' => $dbName, 'table' => $table]);
    $pkCols = $pkStmt->fetchAll(PDO::FETCH_COLUMN);

    $uniqueStmt->execute(['db' => $dbName, 'table' => $table]);
    $uniqueRows = $uniqueStmt->fetchAll();
    $uniques = [];
    foreach ($uniqueRows as $row) {
        $uniques[$row['index_name']][] = $row['column_name'];
    }

    $indexStmt->execute(['db' => $dbName, 'table' => $table]);
    $indexRows = $indexStmt->fetchAll();
    $indexes = [];
    foreach ($indexRows as $row) {
        $indexes[$row['index_name']][] = $row['column_name'];
    }

    $fkStmt->execute(['db' => $dbName, 'table' => $table]);
    $fkRows = $fkStmt->fetchAll();
    $fks = [];
    foreach ($fkRows as $row) {
        $fkName = (string) $row['constraint_name'];
        if (!isset($fks[$fkName])) {
            $fks[$fkName] = [
                'columns' => [],
                'ref_table' => (string) $row['referenced_table_name'],
                'ref_columns' => [],
                'update_rule' => normalizeRule((string) $row['update_rule']),
                'delete_rule' => normalizeRule((string) $row['delete_rule']),
            ];
        }
        $fks[$fkName]['columns'][] = (string) $row['column_name'];
        $fks[$fkName]['ref_columns'][] = (string) $row['referenced_column_name'];
    }

    $schemaInfo[$table] = [
        'columns' => array_map(static fn ($c) => (string) $c['column_name'], $cols),
        'meta' => $colMeta,
        'pk' => $pkCols,
        'uniques' => $uniques,
        'indexes' => $indexes,
        'fks' => $fks,
    ];
}

foreach ($tables as $table) {
    $cols = $schemaInfo[$table]['columns'];
    if (count($cols) === 0) {
        continue;
    }

    $selectSql = 'SELECT * FROM ' . mi($table);
    $stmt = $pdo->query($selectSql);
    $colList = implode(', ', array_map('qi', $cols));

    while (($row = $stmt->fetch()) !== false) {
        $vals = [];
        foreach ($cols as $colName) {
            $vals[] = pgLiteral($row[$colName], $schemaInfo[$table]['meta'][$colName]);
        }

        fwrite(
            $out,
            'INSERT INTO ' . qi($table) . ' (' . $colList . ') VALUES (' . implode(', ', $vals) . ");\n"
        );
    }

    fwrite($out, "\n");
}

foreach ($tables as $table) {
    $pkCols = $schemaInfo[$table]['pk'];
    if (!empty($pkCols)) {
        $pkName = $table . '_pkey';
        $pkColSql = implode(', ', array_map('qi', $pkCols));
        fwrite(
            $out,
            'ALTER TABLE ONLY ' . qi($table) . ' ADD CONSTRAINT ' . qi($pkName) . ' PRIMARY KEY (' . $pkColSql . ");\n"
        );
    }

    foreach ($schemaInfo[$table]['uniques'] as $idxName => $idxCols) {
        $colsSql = implode(', ', array_map('qi', $idxCols));
        fwrite(
            $out,
            'ALTER TABLE ONLY ' . qi($table) . ' ADD CONSTRAINT ' . qi((string) $idxName) . ' UNIQUE (' . $colsSql . ");\n"
        );
    }

    foreach ($schemaInfo[$table]['indexes'] as $idxName => $idxCols) {
        $colsSql = implode(', ', array_map('qi', $idxCols));
        fwrite(
            $out,
            'CREATE INDEX ' . qi((string) $idxName) . ' ON ' . qi($table) . ' (' . $colsSql . ");\n"
        );
    }
}

fwrite($out, "\n");

foreach ($tables as $table) {
    foreach ($schemaInfo[$table]['fks'] as $fkName => $fkDef) {
        $colsSql = implode(', ', array_map('qi', $fkDef['columns']));
        $refColsSql = implode(', ', array_map('qi', $fkDef['ref_columns']));

        fwrite(
            $out,
            'ALTER TABLE ONLY ' . qi($table) .
            ' ADD CONSTRAINT ' . qi((string) $fkName) .
            ' FOREIGN KEY (' . $colsSql . ')' .
            ' REFERENCES ' . qi((string) $fkDef['ref_table']) . ' (' . $refColsSql . ')' .
            ' ON UPDATE ' . $fkDef['update_rule'] .
            ' ON DELETE ' . $fkDef['delete_rule'] .
            ";\n"
        );
    }
}

if (!empty($identityColumns)) {
    fwrite($out, "\n");
}

foreach ($identityColumns as $identity) {
    $table = $identity['table'];
    $column = $identity['column'];

    $tableIdent = qi($table);
    $colIdent = qi($column);
    $tableForSeq = qs($tableIdent);

    fwrite(
        $out,
        'SELECT setval(pg_get_serial_sequence(' . $tableForSeq . ', ' . qs($column) . '), COALESCE((SELECT MAX(' . $colIdent . ') FROM ' . $tableIdent . '), 1), true);' . "\n"
    );
}

fwrite($out, "\nCOMMIT;\n");
fclose($out);

echo "PostgreSQL dump generated at: {$outPath}" . PHP_EOL;
